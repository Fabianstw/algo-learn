import { Question } from "../../components/Question"
import { Language } from "../../utils/translations"

/**
 * Objects of type Question are generated by QuestionGenerators. There are only
 * a handful of question types. Whenever a new QuestionGenerator wants to
 * explore a new interaction pattern, the existing types should be extended with
 * optional properties. If this is not possible, a new question type should be
 * added.
 */
export type Question = MultipleChoiceQuestion | FreeTextQuestion

/**
 * Base type for all question types; they must contain the already-translated
 * question descriptions and texts in markdown-style syntax. All Question object
 * must have at least these properties.
 */
export interface QuestionBase {
  /** The type of the question */
  type: string

  /**
   * Unique path to this question; for example,
   * "/en/topic/questiongenerator1/variant1/VeryRandomSeed". The path must
   * contain _all_ parameters necessary to re-generate the question.
   */
  path: string

  /** The name of the question */
  name: string

  /** The markdown text of the question (optional) */
  text?: string

  /**
   * If true, the client may request feedback on preliminary answers, before the
   * user has clicked "check" (optional)
   */
  allowPreliminaryAnswers?: boolean
}

/**
 * MultipleChoiceQuestion stores the generated data of multiple choice
 * questions.
 */
export interface MultipleChoiceQuestion extends QuestionBase {
  type: "MultipleChoiceQuestion"

  /** List of possible answers to the question */
  answers: string[]

  /** Whether multiple answers can be selected; defaults to false */
  allowMultiple?: boolean

  /** Whether the question is a sorting question; defaults to false */
  sorting?: boolean

  /** The feedback function for this question; defaults to undefined */
  feedback?: MultipleChoiceFeedbackFunction
}

/** The AnswerBase interface is the base type for all answer types. */
export interface AnswerBase {
  /**
   * If true, the answer is only a preliminary answer; the user has not yet
   * submitted the answer. (optional)
   */
  preliminary?: boolean
}

/**
 * After the user selects answer(s), these answeres are stored as a
 * MultipleChoiceAnswer object.
 */
export interface MultipleChoiceAnswer extends AnswerBase {
  /**
   * The indices of all answers selected by the user; the order is relevant only
   * if sortingQuestion is true
   */
  choice: number[]
}

/**
 * The QuestionGenerator provides a feedback function that is given the question
 * and the answer given by the user and returns feedback on the answer. The type
 * of the feedback function depends on the question type, but every feedback
 * must/may contain the fields in the following FeedbackBase interface.
 */
export interface FeedbackBase {
  /**
   * Whether the choice is exactly correct. This field may be withheld, for
   * example, if the correctness is unknown or if the answer was only
   * preliminary and not final.
   */
  correct?: boolean

  /** The feedback text to show to the user. (optional) */
  feedbackText?: string
}

/**
 * The feedback object returned by the feedback function for multiple-choice
 * questions.
 */
export interface MultipleChoiceFeedback extends FeedbackBase {
  /**
   * The correct choice; the order is relevant only if sortingQuestion is true.
   * (optional)
   */
  correctChoice?: number[]
}

/** The signature of the feedback function for multiple-choice questions */
export type MultipleChoiceFeedbackFunction = (
  answer: MultipleChoiceAnswer
) => MultipleChoiceFeedback

/**
 * This function returns a feedback function for multiple-choice questions that
 * checks whether the selected answer or answers are correct. The correct answer
 * is given as a list of indices of the correct answers.
 *
 * @param correctAnswerIndex The index or indices of the correct answer(s)
 * @param sorting Whether the order of the answers is relevant; defaults to
 *   false, in which case the order of the answers is ignored by sorting them
 * @returns
 */
export function minimalMultipleChoiceFeedback({
  correctAnswerIndex,
  sorting = false,
}: {
  correctAnswerIndex: number | number[]
  sorting?: boolean
}): MultipleChoiceFeedbackFunction {
  const correctChoice =
    typeof correctAnswerIndex === "number"
      ? [correctAnswerIndex]
      : correctAnswerIndex.slice()
  if (!sorting) correctChoice.sort()
  const feedback: MultipleChoiceFeedbackFunction = ({ choice }) => {
    const sameLength = choice.length === correctChoice.length
    if (!sorting) choice = choice.slice().sort()
    let sameAnswer = true
    choice.forEach((c, i) => {
      if (c !== correctChoice[i]) sameAnswer = false
    })
    const correct = sameLength && sameAnswer
    return { correct, correctChoice }
  }
  return feedback
}

/**
 * FreeTextQuestion stores the generated data of free text questions. Free text
 * questions are questions where the user can enter any text as an answer.
 */
export interface FreeTextQuestion extends QuestionBase {
  type: "FreeTextQuestion"

  /** The prompt to show to the user next to the input field (optional) */
  prompt?: string

  /** The placeholder text to show in the input field (optional) */
  placeholder?: string

  /**
   * The format of the answer; for example, "number", "email", "python3", ...
   * (optional)
   */
  format?: string

  /** The number of lines in the input field (defaults to 1) */
  lines?: number

  /** The feedback function for this question; defaults to undefined */
  feedback?: FreeTextFeedbackFunction
}

/**
 * After the user enters an answer, this answer is stored as a FreeTextAnswer
 * object.
 */
export interface FreeTextAnswer extends AnswerBase {
  /** The text entered by the user */
  text: string
}

/** For feedback on free-text questions, the base feedback type is sufficient. */
export type FreeTextFeedback = FeedbackBase

/** The signature of the feedback function for free-text questions */
export type FreeTextFeedbackFunction = (
  answer: FreeTextAnswer
) => FreeTextFeedback

/**
 * Each QuestionGenerator may support multiple variants and parameters with
 * which the difficulty and focus of the question can be adjusted. The
 * QuestionGenerator should provide a list of allowed parameters along with
 * their types, descriptions, and allowed values.
 */
export interface ParameterBase {
  name: string
  description: (lang: Language) => string
}

/**
 * IntegerParameters are parameters that can be set to an integer value. They
 * may have a minimum and maximum value.
 */
export interface IntegerParameter extends ParameterBase {
  type: "integer"
  min?: number
  max?: number
}

/**
 * StringParameters are parameters that can be set to a string value. They may
 * have an explicit list of allowed values.
 */
export interface StringParameter extends ParameterBase {
  type: "string"
  allowedValues?: string[]
}

/** AllowedParameter is the union of all allowed parameter types. */
export type AllowedParameter = IntegerParameter | StringParameter

/**
 * An object of type Parameters is what is given as input to the
 * QuestionGenerator to generate a question.
 */
export interface Parameters extends Record<string, string | number> {
  // it would be possible to add mandatory parameters here, such as
  // seed: string
}

/**
 * QuestionGenerator type for generating questions.
 *
 * Here, TQuestion is a generic type that represents the question type, for
 * example MultipleChoiceQuestion, etc.
 */
export interface QuestionGenerator {
  path: string // Can be used as part of the URL (only lower-case letters, numbers and dashes)
  languages: Language[] // List of supported languages
  name: (lang: Language) => string // Readable name of the question
  description: (lang: Language) => string // Short description of the question
  tags?: string[] // Tags for the question
  author?: string // Author of the question
  version?: string // Version of the question
  license?: string // License of the question
  link?: string // Link to the source code of the question

  /** List of allowed parameters for the question. */
  allowedParameters: AllowedParameter[]

  /**
   * Function to generate an instance of the question from the given parameters,
   * as well as the feedback function for this question. The function must be
   * implemented by each QuestionGenerator object.
   *
   * @param parameters The parameters to use when generating the question
   * @param lang The language to use when generating the question
   * @returns The question object including its corresponding feedback function
   *   as a closure. Additional properties may be added to the output object to
   *   provide unit tests.
   */
  generate: (parameters: Parameters, lang?: Language) => { question: Question }
}

/**
 * Function to export the question in JSON format
 *
 * @param question The question to export
 * @returns The question in JSON format
 */
export function questionToJSON(question: Question): string {
  return JSON.stringify(question, null, 2).replace("\\\\", "\\")
}

/**
 * Function to import the question from JSON format
 *
 * @param json The question to import in JSON format
 * @returns The question object
 */
export function questionFromJSON(json: string): Question {
  return JSON.parse(json) as Question
}
